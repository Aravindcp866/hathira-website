{"version":3,"file":"SharedStateContext.cjs","sources":["../../src/react/useOptimistic.ts","../../../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/stringify.js","../../../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/rng.js","../../../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/native.js","../../../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/v4.js","../../src/util/geometry.ts","../../src/util/dragAndDrop.ts","../../src/util/elements.ts","../../src/util/stega.ts","../../src/util/findSanityNodes.ts","../../src/controller.ts","../../src/ui/shared-state/SharedStateContext.ts"],"sourcesContent":["import {getPublishedId} from '@sanity/client/csm'\nimport type {SanityDocument} from '@sanity/types'\nimport {startTransition, useEffect, useInsertionEffect, useRef, useState} from 'react'\nimport {isEmptyActor} from '../optimistic/context'\nimport type {OptimisticReducer, OptimisticReducerAction} from '../optimistic/types'\nimport {useOptimisticActor} from './useOptimisticActor'\n\nexport function useOptimistic<T, U = SanityDocument>(\n  passthrough: T,\n  reducer: OptimisticReducer<T, U> | Array<OptimisticReducer<T, U>>,\n): T {\n  const [pristine, setPristine] = useState(true)\n  const [optimistic, setOptimistic] = useState<T>(passthrough)\n  const [lastEvent, setLastEvent] = useState<OptimisticReducerAction<U> | null>(null)\n  const [lastPassthrough, setLastPassthrough] = useState<T>(passthrough)\n\n  const actor = useOptimisticActor()\n\n  /**\n   * This action is used in two `useEffect` hooks, it needs access to the provided `reducer`,\n   * but doesn't want to cause re-renders if `reducer` changes identity.\n   * The `useInsertionEffect` hook ensures that the `reducer` value is never stale when used, and doesn't trigger setup and teardown of\n   * `useEffect` deps to make it happen.\n   */\n  const reduceStateFromActionRef = useRef<\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ((action: OptimisticReducerAction<U>, prevState: T) => T) | null\n  >(null)\n  useInsertionEffect(() => {\n    reduceStateFromActionRef.current = (action: OptimisticReducerAction<U>, prevState: T) => {\n      const reducers = Array.isArray(reducer) ? reducer : [reducer]\n      return reducers.reduce(\n        (acc, reducer) =>\n          reducer(acc, {\n            document: action.document,\n            id: getPublishedId(action.id),\n            originalId: action.id,\n            type: action.type,\n          }),\n        prevState,\n      )\n    }\n  }, [reducer])\n\n  /**\n   * Records the last passthrough value when reducers ran in response to a rebased event.\n   * This allows us to later know when reducers should run should the passthrough change.\n   */\n  const updateLastPassthroughRef = useRef<() => void>(() => setLastPassthrough(passthrough))\n  useInsertionEffect(() => {\n    updateLastPassthroughRef.current = () => setLastPassthrough(passthrough)\n  }, [passthrough])\n\n  /**\n   * Handle rebase events, which runs the provided reducers,\n   * caches the event that was used to produce the new state,\n   * and marks the state as non-pristine.\n   */\n  useEffect(() => {\n    // If the actor hasn't been set yet, we don't need to subscribe to mutations\n    if (isEmptyActor(actor)) {\n      return\n    }\n\n    /**\n     * The pristine event fires much too soon, so the temporary workaround is that we greatly delay firing `setPristine(true)`,\n     * and instead relying on re-running reducers with the last event whenever the passthrough changes, to preserve the optimistic state,\n     * until we hopefully have eventual consistency on the passthrough.\n     */\n    let pristineTimeout: ReturnType<typeof setTimeout>\n\n    const rebasedSub = actor.on('rebased.local', (_event) => {\n      const event = {\n        // @todo You shall not cast\n        document: _event.document as U,\n        id: _event.id,\n        originalId: getPublishedId(_event.id),\n        // @todo This should eventually be emitted by the state machine\n        type: 'mutate' as const,\n      }\n      setOptimistic((prevState) =>\n        reduceStateFromActionRef.current\n          ? reduceStateFromActionRef.current(event, prevState)\n          : prevState,\n      )\n      setLastEvent(event)\n      updateLastPassthroughRef.current()\n      setPristine(false)\n\n      clearTimeout(pristineTimeout)\n    })\n    const pristineSub = actor.on('pristine', () => {\n      pristineTimeout = setTimeout(() => {\n        // Marking it in a startTransition allows react to interrupt the resulting render, should a new rebase happen and we're back to dirty\n        startTransition(() => setPristine(true))\n      }, 15000)\n    })\n    return () => {\n      rebasedSub.unsubscribe()\n      pristineSub.unsubscribe()\n    }\n  }, [actor])\n\n  /**\n   * If the passthrough changes, and we are in a dirty state, we rerun the reducers with the new passthrough but the previous event.\n   * Marking it in a transition allows react to interrupt this render should a new action happen, or should we be back in a pristine state.\n   */\n  useEffect(() => {\n    if (pristine) {\n      // if we are pristine, then we will passthrough anyway\n      return undefined\n    }\n    if (!lastEvent) {\n      // If we don't have a lastEvent when we are pristine, it's a fatal error\n      throw new Error('No last event found when syncing passthrough')\n    }\n    if (lastPassthrough === passthrough) {\n      // If the passthrough hasn't changed, then we don't need to rerun the reducers\n      return undefined\n    }\n\n    // Marking it in a startTransition allows react to interrupt the resulting render, should a new rebase happen\n    startTransition(() => {\n      setOptimistic(\n        reduceStateFromActionRef.current\n          ? reduceStateFromActionRef.current(lastEvent, passthrough)\n          : passthrough,\n      )\n      setLastPassthrough(passthrough)\n    })\n  }, [lastEvent, lastPassthrough, passthrough, pristine])\n\n  return pristine ? passthrough : optimistic\n}\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n","import type {OverlayRect, Point2D, Ray2D} from '../types'\n\nexport function getRect(element: Element): OverlayRect {\n  const domRect = element.getBoundingClientRect()\n\n  const rect = {\n    x: domRect.x + scrollX,\n    y: domRect.y + scrollY,\n    w: domRect.width,\n    h: domRect.height,\n  }\n\n  return rect\n}\n\nexport function offsetRect(rect: OverlayRect, px: number, axis: 'x' | 'y'): OverlayRect {\n  if (axis === 'x') {\n    return {\n      x: rect.x + px,\n      y: rect.y,\n      w: rect.w - 2 * px,\n      h: rect.h,\n    }\n  } else {\n    return {\n      x: rect.x,\n      y: rect.y + px,\n      w: rect.w,\n      h: rect.h - 2 * px,\n    }\n  }\n}\n\n// Ref http://paulbourke.net/geometry/pointlineplane/\nexport function rayIntersect(l1: Ray2D, l2: Ray2D): Point2D | false {\n  const {x1, y1, x2, y2} = l1\n  const {x1: x3, y1: y3, x2: x4, y2: y4} = l2\n\n  // Check if none of the lines are of length 0\n  if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n    return false\n  }\n\n  const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n\n  // Lines are parallel\n  if (denominator === 0) {\n    return false\n  }\n\n  const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator\n  const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator\n\n  // is the intersection along the segments\n  if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n    return false\n  }\n\n  const x = x1 + ua * (x2 - x1)\n  const y = y1 + ua * (y2 - y1)\n\n  return {x, y}\n}\n\nexport function rectEqual(r1: OverlayRect, r2: OverlayRect): boolean {\n  return r1.x === r2.x && r1.y === r2.y && r1.w === r2.w && r1.h === r2.h\n}\n\nexport function rayRectIntersections(line: Ray2D, rect: OverlayRect): Array<Point2D> | false {\n  const rectLines: Array<Ray2D> = [\n    {x1: rect.x, y1: rect.y, x2: rect.x + rect.w, y2: rect.y},\n    {\n      x1: rect.x + rect.w,\n      y1: rect.y,\n      x2: rect.x + rect.w,\n      y2: rect.y + rect.h,\n    },\n    {\n      x1: rect.x + rect.w,\n      y1: rect.y + rect.h,\n      x2: rect.x,\n      y2: rect.y + rect.h,\n    },\n    {\n      x1: rect.x,\n      y1: rect.y + rect.h,\n      x2: rect.x,\n      y2: rect.y,\n    },\n  ]\n\n  const intersections: Array<Point2D> = []\n\n  for (let i = 0; i < rectLines.length; i++) {\n    const intersection = rayIntersect(line, rectLines[i])\n\n    if (intersection) {\n      let isDuplicate = false\n\n      for (let j = 0; j < intersections.length; j++) {\n        if (intersections[j].x === intersection.x && intersections[j].y === intersection.y) {\n          isDuplicate = true\n        }\n      }\n\n      if (!isDuplicate) intersections.push(intersection)\n    }\n  }\n\n  if (intersections.length === 0) {\n    return false\n  }\n\n  return intersections.sort(\n    (a, b) => pointDist(a, {x: line.x1, y: line.y1}) - pointDist(b, {x: line.x1, y: line.y1}),\n  )\n}\nexport function pointDist(p1: Point2D, p2: Point2D): number {\n  const a = p1.x - p2.x\n  const b = p1.y - p2.y\n\n  return Math.sqrt(a * a + b * b)\n}\n\nexport function pointInBounds(point: Point2D, bounds: OverlayRect): boolean {\n  const withinX = point.x >= bounds.x && point.x <= bounds.x + bounds.w\n  const withinY = point.y >= bounds.y && point.y <= bounds.y + bounds.h\n\n  return withinX && withinY\n}\n\nexport function findClosestIntersection(\n  ray: Ray2D,\n  targets: OverlayRect[],\n  flow: string,\n): OverlayRect | null {\n  const rayOrigin = {\n    x: ray.x1,\n    y: ray.y1,\n  }\n\n  // Offset rects to ensure raycasting works when siblings touch\n  if (\n    targets.some((t) =>\n      pointInBounds(\n        rayOrigin,\n        offsetRect(t, Math.min(t.w, t.h) / 10, flow === 'horizontal' ? 'x' : 'y'),\n      ),\n    )\n  )\n    return null\n  let closestIntersection\n  let closestRect\n\n  for (const target of targets) {\n    const intersections = rayRectIntersections(\n      ray,\n      offsetRect(target, Math.min(target.w, target.h) / 10, flow === 'horizontal' ? 'x' : 'y'),\n    )\n    if (intersections) {\n      const firstIntersection = intersections[0]\n\n      if (closestIntersection) {\n        if (pointDist(rayOrigin, firstIntersection) < pointDist(rayOrigin, closestIntersection)) {\n          closestIntersection = firstIntersection\n          closestRect = target\n        }\n      } else {\n        closestIntersection = firstIntersection\n        closestRect = target\n      }\n    }\n  }\n\n  if (closestRect) return closestRect\n\n  return null\n}\n\nexport function scaleRect(\n  rect: OverlayRect,\n  scale: number,\n  origin: {x: number; y: number},\n): OverlayRect {\n  const {x, y, w, h} = rect\n  const {x: originX, y: originY} = origin\n\n  const newX = originX + (x - originX) * scale\n  const newY = originY + (y - originY) * scale\n\n  const newWidth = w * scale\n  const newHeight = h * scale\n\n  return {\n    x: newX,\n    y: newY,\n    w: newWidth,\n    h: newHeight,\n  }\n}\n\nexport function getRectGroupXExtent(rects: OverlayRect[]): {\n  min: number\n  max: number\n  width: number\n} {\n  const minGroupX = Math.max(0, Math.min(...rects.map((r) => r.x)))\n  const maxGroupX = Math.min(document.body.offsetWidth, Math.max(...rects.map((r) => r.x + r.w)))\n\n  return {\n    min: minGroupX,\n    max: maxGroupX,\n    width: maxGroupX - minGroupX,\n  }\n}\n\nexport function getRectGroupYExtent(rects: OverlayRect[]): {\n  min: number\n  max: number\n  height: number\n} {\n  const minGroupY = Math.max(0, Math.min(...rects.map((r) => r.y)))\n  const maxGroupY = Math.min(document.body.scrollHeight, Math.max(...rects.map((r) => r.y + r.h)))\n\n  return {\n    min: minGroupY,\n    max: maxGroupY,\n    height: maxGroupY - minGroupY,\n  }\n}\n","import type {\n  DragInsertPosition,\n  DragInsertPositionRects,\n  ElementNode,\n  OverlayElement,\n  OverlayEventHandler,\n  OverlayRect,\n  Point2D,\n  SanityNode,\n} from '../types'\nimport {\n  findClosestIntersection,\n  getRect,\n  getRectGroupXExtent,\n  getRectGroupYExtent,\n  pointDist,\n  rectEqual,\n  scaleRect,\n} from './geometry'\n\nfunction calcTargetFlow(targets: OverlayRect[]) {\n  if (\n    targets.some((t1) => {\n      const others = targets.filter((t2) => !rectEqual(t1, t2))\n\n      return others.some((t2) => {\n        return t1.y === t2.y\n      })\n    })\n  ) {\n    return 'horizontal'\n  } else {\n    return 'vertical'\n  }\n}\n\nfunction calcInsertPosition(origin: Point2D, targets: OverlayRect[], flow: string) {\n  if (flow === 'horizontal') {\n    const rayLeft = {\n      x1: origin.x,\n      y1: origin.y,\n      x2: origin.x - 100_000_000,\n      y2: origin.y,\n    }\n\n    const rayRight = {\n      x1: origin.x,\n      y1: origin.y,\n      x2: origin.x + 100_000_000,\n      y2: origin.y,\n    }\n\n    return {\n      left: findClosestIntersection(rayLeft, targets, flow),\n      right: findClosestIntersection(rayRight, targets, flow),\n    }\n  } else {\n    const rayTop = {\n      x1: origin.x,\n      y1: origin.y,\n      x2: origin.x,\n      y2: origin.y - 100_000_000,\n    }\n\n    const rayBottom = {\n      x1: origin.x,\n      y1: origin.y,\n      x2: origin.x,\n      y2: origin.y + 100_000_000,\n    }\n\n    return {\n      top: findClosestIntersection(rayTop, targets, flow),\n      bottom: findClosestIntersection(rayBottom, targets, flow),\n    }\n  }\n}\n\nfunction findRectSanityData(rect: OverlayRect, overlayGroup: OverlayElement[]) {\n  return overlayGroup.find((e) => rectEqual(getRect(e.elements.element), rect))\n    ?.sanity as SanityNode\n}\n\nfunction resolveInsertPosition(\n  overlayGroup: OverlayElement[],\n  insertPosition: DragInsertPositionRects,\n  flow: string,\n): DragInsertPosition {\n  if (Object.values(insertPosition).every((v) => v === null)) return null\n\n  if (flow === 'horizontal') {\n    return {\n      left: insertPosition.left\n        ? {\n            rect: insertPosition.left,\n            sanity: findRectSanityData(insertPosition.left, overlayGroup),\n          }\n        : null,\n      right: insertPosition.right\n        ? {\n            rect: insertPosition.right,\n            sanity: findRectSanityData(insertPosition.right, overlayGroup),\n          }\n        : null,\n    }\n  } else {\n    return {\n      top: insertPosition.top\n        ? {\n            rect: insertPosition.top,\n            sanity: findRectSanityData(insertPosition.top, overlayGroup),\n          }\n        : null,\n      bottom: insertPosition.bottom\n        ? {\n            rect: insertPosition.bottom,\n            sanity: findRectSanityData(insertPosition.bottom, overlayGroup),\n          }\n        : null,\n    }\n  }\n}\n\nfunction calcMousePos(e: MouseEvent) {\n  const bodyBounds = document.body.getBoundingClientRect()\n\n  return {\n    x: Math.max(bodyBounds.x, Math.min(e.clientX, bodyBounds.x + bodyBounds.width)),\n    y: e.clientY + window.scrollY,\n  }\n}\n\nfunction calcMousePosInverseTransform(mousePos: Point2D) {\n  const body = document.body\n  const computedStyle = window.getComputedStyle(body)\n  const transform = computedStyle.transform\n\n  if (transform === 'none') {\n    return {\n      x: mousePos.x,\n      y: mousePos.y,\n    }\n  }\n\n  const matrix = new DOMMatrix(transform)\n  const inverseMatrix = matrix.inverse()\n\n  const point = new DOMPoint(mousePos.x, mousePos.y)\n  const transformedPoint = point.matrixTransform(inverseMatrix)\n\n  return {\n    x: transformedPoint.x,\n    y: transformedPoint.y,\n  }\n}\n\nfunction buildPreviewSkeleton(mousePos: Point2D, element: ElementNode, scaleFactor: number) {\n  const bounds = getRect(element)\n\n  const children = [\n    ...element.querySelectorAll(':where(h1, h2, h3, h4, p, a, img, span, button):not(:has(*))'),\n  ]\n\n  if (mousePos.x <= bounds.x) mousePos.x = bounds.x\n  if (mousePos.x >= bounds.x + bounds.w) mousePos.x = bounds.x + bounds.w\n\n  if (mousePos.y >= bounds.y + bounds.h) mousePos.y = bounds.y + bounds.h\n  if (mousePos.y <= bounds.y) mousePos.y = bounds.y\n\n  const childRects = children.map((child: Element) => {\n    // offset to account for stroke in rendered rects\n    const rect = scaleRect(getRect(child), scaleFactor, {\n      x: bounds.x,\n      y: bounds.y,\n    })\n\n    return {\n      x: rect.x - bounds.x,\n      y: rect.y - bounds.y,\n      w: rect.w,\n      h: rect.h,\n      tagName: child.tagName,\n    }\n  })\n\n  return {\n    offsetX: (bounds.x - mousePos.x) * scaleFactor,\n    offsetY: (bounds.y - mousePos.y) * scaleFactor,\n    w: bounds.w * scaleFactor,\n    h: bounds.h * scaleFactor,\n    maxWidth: bounds.w * scaleFactor * 0.75,\n    childRects,\n  }\n}\n\nconst minDragDelta = 4\n\nasync function applyMinimapWrapperTransform(\n  target: HTMLElement,\n  scaleFactor: number,\n  minYScaled: number,\n  handler: OverlayEventHandler,\n  rectUpdateFrequency: number,\n): Promise<void> {\n  return new Promise((resolve) => {\n    target.addEventListener(\n      'transitionend',\n      () => {\n        setTimeout(() => {\n          handler({\n            type: 'overlay/dragEndMinimapTransition',\n          })\n        }, rectUpdateFrequency * 2)\n\n        resolve()\n      },\n      {once: true},\n    )\n\n    handler({\n      type: 'overlay/dragStartMinimapTransition',\n    })\n\n    handler({\n      type: 'overlay/dragToggleMinimap',\n      display: true,\n    })\n\n    document.body.style.overflow = 'hidden'\n    document.body.style.height = '100%'\n    document.documentElement.style.overflow = 'initial'\n    document.documentElement.style.height = '100%'\n\n    // ensure overflow hidden has applied and scrolling stopped before applying transform, prevent minor y-position transform issues\n    setTimeout(() => {\n      target.style.transformOrigin = '50% 0px'\n      target.style.transition = 'transform 150ms ease'\n      target.style.transform = `translate3d(0px, ${-minYScaled + scrollY}px, 0px) scale(${scaleFactor})`\n    }, 25)\n  })\n}\n\nfunction calcMinimapTransformValues(rects: OverlayRect[], groupHeightOverride: number | null) {\n  let groupHeight = groupHeightOverride || getRectGroupYExtent(rects).height\n\n  const padding = 100 // px\n\n  groupHeight += padding * 2\n\n  const scaleFactor = groupHeight > window.innerHeight ? window.innerHeight / groupHeight : 1\n  const scaledRects = rects.map((r) => scaleRect(r, scaleFactor, {x: window.innerWidth / 2, y: 0}))\n\n  const {min: minYScaled} = getRectGroupYExtent(scaledRects)\n\n  return {\n    scaleFactor,\n    minYScaled: minYScaled - padding * scaleFactor,\n  }\n}\nfunction calcGroupBoundsPreview(rects: OverlayRect[]) {\n  const groupBoundsX = getRectGroupXExtent(rects)\n  const groupBoundsY = getRectGroupYExtent(rects)\n\n  const offsetDist = 8\n\n  const canOffsetX =\n    groupBoundsX.min > offsetDist &&\n    groupBoundsX.min + groupBoundsX.width <= window.innerWidth - offsetDist\n  const canOffsetY =\n    groupBoundsY.min > offsetDist &&\n    groupBoundsY.min + groupBoundsY.height <= document.body.scrollHeight - offsetDist\n  const canOffset = canOffsetX && canOffsetY\n\n  const groupRect = {\n    x: canOffset ? groupBoundsX.min - offsetDist : groupBoundsX.min,\n    y: canOffset ? groupBoundsY.min - offsetDist : groupBoundsY.min,\n    w: canOffset ? groupBoundsX.width + offsetDist * 2 : groupBoundsX.width,\n    h: canOffset ? groupBoundsY.height + offsetDist * 2 : groupBoundsY.height,\n  }\n\n  return groupRect\n}\n\nasync function resetMinimapWrapperTransform(\n  endYOrigin: number,\n  target: HTMLElement,\n  prescaleHeight: number,\n  handler: OverlayEventHandler,\n  rectUpdateFrequency: number,\n  previousRootStyleValues: PreviousRootStyleValues | null,\n): Promise<void> {\n  return new Promise((resolve) => {\n    const computedStyle = window.getComputedStyle(target)\n    const transform = computedStyle.transform\n\n    const matrix = new DOMMatrix(transform)\n\n    const scale = matrix.a\n\n    if (scale === 1) return\n\n    const maxScroll = prescaleHeight - window.innerHeight\n    const prevScrollY = scrollY\n\n    endYOrigin -= window.innerHeight / 2\n\n    if (endYOrigin < 0) endYOrigin = 0\n\n    target.addEventListener(\n      'transitionend',\n      () => {\n        target.style.transition = `none`\n        target.style.transform = `none`\n\n        scrollTo({\n          top: endYOrigin,\n          behavior: 'instant',\n        })\n\n        setTimeout(() => {\n          handler({\n            type: 'overlay/dragEndMinimapTransition',\n          })\n\n          handler({\n            type: 'overlay/dragToggleMinimap',\n            display: false,\n          })\n        }, rectUpdateFrequency * 2)\n\n        resolve()\n      },\n      {once: true},\n    )\n\n    handler({\n      type: 'overlay/dragStartMinimapTransition',\n    })\n\n    target.style.transform = `translateY(${Math.max(prevScrollY - endYOrigin, -maxScroll + prevScrollY)}px) scale(${1})`\n\n    if (!previousRootStyleValues) return\n\n    document.body.style.overflow = previousRootStyleValues.body.overflow\n    document.body.style.height = previousRootStyleValues.body.height\n    document.documentElement.style.overflow = previousRootStyleValues.documentElement.overflow\n    document.documentElement.style.height = previousRootStyleValues.documentElement.height\n  })\n}\n\ninterface PreviousRootStyleValues {\n  body: {\n    overflow: string\n    height: string\n  }\n  documentElement: {\n    overflow: string\n    height: string\n  }\n}\n\ninterface HandleOverlayDragOpts {\n  mouseEvent: MouseEvent\n  element: ElementNode\n  overlayGroup: OverlayElement[]\n  handler: OverlayEventHandler\n  target: SanityNode\n  onSequenceStart: () => void\n  onSequenceEnd: () => void\n}\n\nlet minimapScaleApplied = false\n\nlet mousePosInverseTransform = {x: 0, y: 0}\nlet mousePos = {x: 0, y: 0}\n\nlet prescaleHeight = typeof document === 'undefined' ? 0 : document.documentElement.scrollHeight\n\nlet previousRootStyleValues: PreviousRootStyleValues | null = null\n\nexport function handleOverlayDrag(opts: HandleOverlayDragOpts): void {\n  const {mouseEvent, element, overlayGroup, handler, target, onSequenceStart, onSequenceEnd} = opts\n\n  // do not trigger drag sequence on anything other than \"main\" (0) click, ignore right click, etc\n  if (mouseEvent.button !== 0) return\n\n  // ensure keyboard events fire within frame context\n  window.focus()\n\n  const rectUpdateFrequency = 150\n  let rects = overlayGroup.map((e) => getRect(e.elements.element))\n\n  const flow = (element.getAttribute('data-sanity-drag-flow') || calcTargetFlow(rects)) as\n    | 'horizontal'\n    | 'vertical'\n\n  const dragGroup = element.getAttribute('data-sanity-drag-group')\n\n  const disableMinimap = !!element.getAttribute('data-sanity-drag-minimap-disable')\n\n  const preventInsertDefault = !!element.getAttribute('data-sanity-drag-prevent-default')\n\n  const documentHeightOverride = element.getAttribute('data-unstable_sanity-drag-document-height')\n  const groupHeightOverride = element.getAttribute('data-unstable_sanity-drag-group-height')\n\n  let insertPosition: DragInsertPositionRects | null = null\n\n  const initialMousePos = calcMousePos(mouseEvent)\n\n  const scaleTarget = document.body\n\n  const {minYScaled, scaleFactor} = calcMinimapTransformValues(\n    rects,\n    groupHeightOverride ? ~~groupHeightOverride : null,\n  )\n\n  let sequenceStarted = false\n  let minimapPromptShown = false\n\n  let mousedown = true\n\n  if (!minimapScaleApplied) {\n    previousRootStyleValues = {\n      body: {\n        overflow: window.getComputedStyle(document.body).overflow,\n        height: window.getComputedStyle(document.body).height,\n      },\n      documentElement: {\n        overflow: window.getComputedStyle(document.documentElement).overflow,\n        height: window.getComputedStyle(document.documentElement).height,\n      },\n    }\n\n    prescaleHeight = documentHeightOverride\n      ? ~~documentHeightOverride\n      : document.documentElement.scrollHeight\n  }\n\n  const rectsInterval = setInterval(() => {\n    rects = overlayGroup.map((e) => getRect(e.elements.element))\n  }, rectUpdateFrequency)\n\n  const applyMinimap = (): void => {\n    if (scaleFactor >= 1) return\n\n    const skeleton = buildPreviewSkeleton(mousePos, element, scaleFactor)\n\n    handler({\n      type: 'overlay/dragUpdateSkeleton',\n      skeleton,\n    })\n\n    handler({\n      type: 'overlay/dragToggleMinimapPrompt',\n      display: false,\n    })\n\n    applyMinimapWrapperTransform(\n      scaleTarget,\n      scaleFactor,\n      minYScaled,\n      handler,\n      rectUpdateFrequency,\n    ).then(() => {\n      setTimeout(() => {\n        handler({\n          type: 'overlay/dragUpdateGroupRect',\n          groupRect: calcGroupBoundsPreview(rects),\n        })\n      }, rectUpdateFrequency * 2)\n    })\n  }\n\n  const handleScroll = (e: WheelEvent) => {\n    if (\n      Math.abs(e.deltaY) >= 10 &&\n      scaleFactor < 1 &&\n      !minimapScaleApplied &&\n      !minimapPromptShown &&\n      !disableMinimap &&\n      mousedown\n    ) {\n      handler({\n        type: 'overlay/dragToggleMinimapPrompt',\n        display: true,\n      })\n\n      minimapPromptShown = true\n    }\n\n    if (e.shiftKey && !minimapScaleApplied && !disableMinimap) {\n      window.dispatchEvent(new CustomEvent('unstable_sanity/dragApplyMinimap'))\n\n      minimapScaleApplied = true\n\n      setTimeout(() => {\n        applyMinimap()\n      }, 50)\n    }\n  }\n\n  const handleMouseMove = (e: MouseEvent): void => {\n    e.preventDefault()\n\n    mousePos = calcMousePos(e)\n    mousePosInverseTransform = calcMousePosInverseTransform(mousePos)\n\n    if (Math.abs(pointDist(mousePos, initialMousePos)) < minDragDelta) return\n\n    if (!sequenceStarted) {\n      const groupRect = calcGroupBoundsPreview(rects)\n\n      const skeleton = buildPreviewSkeleton(mousePos, element, 1)\n\n      handler({\n        type: 'overlay/dragStart',\n        flow,\n      })\n\n      handler({\n        type: 'overlay/dragUpdateSkeleton',\n        skeleton,\n      })\n\n      handler({\n        type: 'overlay/dragUpdateGroupRect',\n        groupRect,\n      })\n\n      sequenceStarted = true\n      onSequenceStart()\n    }\n\n    handler({\n      type: 'overlay/dragUpdateCursorPosition',\n      x: mousePos.x,\n      y: mousePos.y,\n    })\n\n    if (e.shiftKey && !minimapScaleApplied && !disableMinimap) {\n      window.dispatchEvent(new CustomEvent('unstable_sanity/dragApplyMinimap'))\n\n      minimapScaleApplied = true\n\n      setTimeout(() => {\n        applyMinimap()\n      }, 50)\n    }\n\n    const newInsertPosition = calcInsertPosition(mousePos, rects, flow)\n\n    if (JSON.stringify(insertPosition) !== JSON.stringify(newInsertPosition)) {\n      insertPosition = newInsertPosition\n\n      handler({\n        type: 'overlay/dragUpdateInsertPosition',\n        insertPosition: resolveInsertPosition(overlayGroup, insertPosition, flow),\n      })\n    }\n  }\n\n  const handleMouseUp = (): void => {\n    mousedown = false\n\n    handler({\n      type: 'overlay/dragEnd',\n      target,\n      insertPosition: insertPosition\n        ? resolveInsertPosition(overlayGroup, insertPosition, flow)\n        : null,\n      dragGroup,\n      flow,\n      preventInsertDefault,\n    })\n\n    if (minimapPromptShown) {\n      handler({\n        type: 'overlay/dragToggleMinimapPrompt',\n        display: false,\n      })\n    }\n\n    if (!minimapScaleApplied) {\n      clearInterval(rectsInterval)\n      onSequenceEnd()\n\n      removeFrameListeners()\n      removeKeyListeners()\n    }\n\n    removeMouseListeners()\n  }\n\n  const handleKeyup = (e: KeyboardEvent) => {\n    if (e.key === 'Shift' && minimapScaleApplied) {\n      minimapScaleApplied = false\n\n      const skeleton = buildPreviewSkeleton(mousePos, element, 1 / scaleFactor)\n\n      handler({\n        type: 'overlay/dragUpdateSkeleton',\n        skeleton,\n      })\n\n      window.dispatchEvent(new CustomEvent('unstable_sanity/dragResetMinimap'))\n\n      setTimeout(() => {\n        resetMinimapWrapperTransform(\n          mousePosInverseTransform.y,\n          scaleTarget,\n          prescaleHeight,\n          handler,\n          rectUpdateFrequency,\n          previousRootStyleValues,\n        )\n      }, 50)\n\n      handler({\n        type: 'overlay/dragUpdateGroupRect',\n        groupRect: null,\n      })\n\n      // cleanup keyup after drag sequence is complete\n      if (!mousedown) {\n        clearInterval(rectsInterval)\n\n        removeMouseListeners()\n        removeFrameListeners()\n        removeKeyListeners()\n\n        onSequenceEnd()\n      }\n    }\n  }\n\n  const handleBlur = () => {\n    handler({\n      type: 'overlay/dragUpdateGroupRect',\n      groupRect: null,\n    })\n\n    window.dispatchEvent(new CustomEvent('unstable_sanity/dragResetMinimap'))\n\n    setTimeout(() => {\n      resetMinimapWrapperTransform(\n        mousePosInverseTransform.y,\n        scaleTarget,\n        prescaleHeight,\n        handler,\n        rectUpdateFrequency,\n        previousRootStyleValues,\n      ).then(() => {\n        minimapScaleApplied = false\n      })\n    }, 50)\n\n    clearInterval(rectsInterval)\n\n    removeMouseListeners()\n    removeFrameListeners()\n    removeKeyListeners()\n\n    onSequenceEnd()\n  }\n\n  const removeMouseListeners = () => {\n    window.removeEventListener('mousemove', handleMouseMove)\n    window.removeEventListener('wheel', handleScroll)\n    window.removeEventListener('mouseup', handleMouseUp)\n  }\n\n  const removeKeyListeners = () => {\n    window.removeEventListener('keyup', handleKeyup)\n  }\n\n  const removeFrameListeners = () => {\n    window.removeEventListener('blur', handleBlur)\n  }\n\n  window.addEventListener('blur', handleBlur)\n  window.addEventListener('keyup', handleKeyup)\n  window.addEventListener('wheel', handleScroll)\n  window.addEventListener('mousemove', handleMouseMove)\n  window.addEventListener('mouseup', handleMouseUp)\n}\n","import type {ElementNode} from '../types'\n\nexport const isElementNode = (target: EventTarget | null): target is ElementNode => {\n  return target instanceof HTMLElement || target instanceof SVGElement\n}\n\nexport function findNonInlineElement(element: ElementNode): ElementNode | null {\n  const {display} = window.getComputedStyle(element)\n\n  if (display !== 'inline') return element\n\n  const parent = element.parentElement\n\n  if (!parent) return null\n\n  return findNonInlineElement(parent)\n}\n\nexport const findOverlayElement = (\n  el: EventTarget | ElementNode | null | undefined,\n): ElementNode | null => {\n  if (!el || !isElementNode(el)) {\n    return null\n  }\n\n  if (el.dataset?.['sanityOverlayElement']) {\n    return el\n  }\n\n  return findOverlayElement(el.parentElement)\n}\n","import type {SanityStegaNode} from '@sanity/presentation-comlink'\nimport {vercelStegaDecode} from '@vercel/stega'\nimport {VERCEL_STEGA_REGEX} from '../constants'\n\n/**\n * JavaScript regexps are stateful. Have to reset lastIndex between runs to ensure consistent behaviour for the same string\n * @param input\n */\nexport function testVercelStegaRegex(input: string): boolean {\n  VERCEL_STEGA_REGEX.lastIndex = 0\n  return VERCEL_STEGA_REGEX.test(input)\n}\n\nfunction decodeStega(str: string, isAltText = false): SanityStegaNode | null {\n  try {\n    const decoded = vercelStegaDecode<SanityStegaNode>(str)\n    if (!decoded || decoded.origin !== 'sanity.io') {\n      return null\n    }\n    if (isAltText) {\n      // @TODO hmmmm is this correct?\n      decoded.href = decoded.href?.replace('.alt', '')\n    }\n    return decoded\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error('Failed to decode stega for string: ', str, 'with the original error: ', err)\n    return null\n  }\n}\n\nexport function testAndDecodeStega(str: string, isAltText = false): SanityStegaNode | null {\n  if (testVercelStegaRegex(str)) {\n    return decodeStega(str, isAltText)\n  }\n  return null\n}\n","import {decodeSanityNodeData} from '@sanity/visual-editing-csm'\nimport type {\n  ElementNode,\n  OverlayElement,\n  ResolvedElement,\n  ResolvedElementReason,\n  ResolvedElementTarget,\n  ResolvingElement,\n  SanityNode,\n  SanityStegaNode,\n} from '../types'\nimport {findNonInlineElement} from './elements'\nimport {testAndDecodeStega, testVercelStegaRegex} from './stega'\n\nconst isElementNode = (node: ChildNode): node is ElementNode => node.nodeType === Node.ELEMENT_NODE\n\nconst isImgElement = (el: ElementNode): el is HTMLImageElement => el.tagName === 'IMG'\n\nconst isTimeElement = (el: ElementNode): el is HTMLTimeElement => el.tagName === 'TIME'\n\nconst isSvgRootElement = (el: ElementNode): el is SVGSVGElement =>\n  el.tagName.toUpperCase() === 'SVG'\n\nexport function isSanityNode(node: SanityNode | SanityStegaNode): node is SanityNode {\n  return 'path' in node\n}\n\n/**\n * Finds commonality between two document paths strings\n * @param first First path to compare\n * @param second Second path to compare\n * @returns A common path\n */\nexport function findCommonPath(first: string, second: string): string {\n  let firstParts = first.split('.')\n  let secondParts = second.split('.')\n  const maxLength = Math.min(firstParts.length, secondParts.length)\n  firstParts = firstParts.slice(0, maxLength).reverse()\n  secondParts = secondParts.slice(0, maxLength).reverse()\n\n  return firstParts\n    .reduce((parts, part, i) => (part === secondParts[i] ? [...parts, part] : []), [] as string[])\n    .reverse()\n    .join('.')\n}\n\n/**\n * Returns common Sanity node data from multiple nodes\n * If document paths are present, tries to resolve a common path\n * @param nodes An array of Sanity nodes\n * @returns A single sanity node or undefined\n * @internal\n */\nexport function findCommonSanityData(\n  nodes: (SanityNode | SanityStegaNode)[],\n): SanityNode | SanityStegaNode | undefined {\n  // If there are no nodes, or inconsistent node types\n  if (!nodes.length || !nodes.map((n) => isSanityNode(n)).every((n, _i, arr) => n === arr[0])) {\n    return undefined\n  }\n  // If legacy nodes, return first match (no common pathfinding)\n  if (!isSanityNode(nodes[0])) return nodes[0]\n\n  const sanityNodes = nodes.filter(isSanityNode)\n  let common: SanityNode | undefined = nodes[0]\n\n  const consistentValueKeys: Array<keyof SanityNode> = [\n    'projectId',\n    'dataset',\n    'id',\n    'baseUrl',\n    'workspace',\n    'tool',\n  ]\n  for (let i = 1; i < sanityNodes.length; i++) {\n    const node = sanityNodes[i]\n    if (consistentValueKeys.some((key) => node[key] !== common?.[key])) {\n      common = undefined\n      break\n    }\n\n    common = {...common, path: findCommonPath(common.path, node.path)}\n  }\n\n  return common\n}\n\n/**\n * Finds nodes containing sanity specific data\n * @param el - A parent element to traverse\n * @returns An array of overlay targets\n * @internal\n */\nexport function findSanityNodes(\n  el: ElementNode | ChildNode | {childNodes: Array<ElementNode>},\n): ResolvedElement[] {\n  const mainResults: Omit<ResolvedElement, 'commonSanity'>[] = []\n\n  function createResolvedElement(\n    element: ElementNode,\n    data: SanityStegaNode | string,\n    reason: ResolvedElementReason,\n    preventGrouping?: boolean,\n  ): ResolvingElement | undefined {\n    const sanity = decodeSanityNodeData(data)\n\n    if (!sanity) {\n      return\n    }\n\n    // resize observer does not fire for non-replaced inline elements https://drafts.csswg.org/resize-observer/#intro\n    const measureElement = findNonInlineElement(element)\n    if (!measureElement) {\n      return\n    }\n\n    return {\n      elements: {\n        element,\n        measureElement,\n      },\n      sanity,\n      reason,\n      preventGrouping,\n    }\n  }\n\n  function resolveNode(node: ChildNode): ResolvingElement | undefined {\n    const {nodeType, parentElement, textContent} = node\n    // If an edit target is found, find common paths\n    if (isElementNode(node) && node.dataset?.['sanityEditTarget'] !== undefined) {\n      const nodesInTarget = findSanityNodes(node)\n      const commonData = findCommonSanityData(\n        nodesInTarget\n          .map((node) => (node.type === 'element' ? node.commonSanity : undefined))\n          .filter((n) => n !== undefined),\n      )\n      if (commonData) {\n        return {\n          reason: 'edit-target',\n          elements: {\n            element: node,\n            measureElement: node,\n          },\n          sanity: commonData,\n        }\n      }\n\n      // Check non-empty, child-only text nodes for stega strings\n    } else if (nodeType === Node.TEXT_NODE && parentElement && textContent) {\n      const data = testAndDecodeStega(textContent)\n      if (!data) return\n      return createResolvedElement(parentElement, data, 'stega-text', true)\n    }\n    // Check element nodes for data attributes, alt tags, etc\n    else if (isElementNode(node)) {\n      // Do not traverse script tags\n      // Do not traverse the visual editing overlay\n      if (node.tagName === 'SCRIPT' || node.tagName === 'SANITY-VISUAL-EDITING') {\n        return\n      }\n\n      // Prefer elements with explicit data attributes\n      if (node.dataset?.['sanity']) {\n        return createResolvedElement(\n          node,\n          node.dataset['sanity'],\n          'data-attribute',\n          Boolean(node.textContent && testVercelStegaRegex(node.textContent)),\n        )\n      }\n      // Look for legacy sanity data attributes\n      else if (node.dataset?.['sanityEditInfo']) {\n        return createResolvedElement(\n          node,\n          node.dataset['sanityEditInfo'],\n          'data-attribute',\n          Boolean(node.textContent && testVercelStegaRegex(node.textContent)),\n        )\n      } else if (isImgElement(node)) {\n        const data = testAndDecodeStega(node.alt, true)\n        if (!data) return\n        return createResolvedElement(node, data, 'stega-attribute')\n      } else if (isTimeElement(node)) {\n        const data = testAndDecodeStega(node.dateTime, true)\n        if (!data) return\n        return createResolvedElement(node, data, 'stega-attribute')\n      } else if (isSvgRootElement(node)) {\n        if (!node.ariaLabel) return\n        const data = testAndDecodeStega(node.ariaLabel, true)\n        if (!data) return\n        return createResolvedElement(node, data, 'stega-attribute')\n      }\n    }\n    return\n  }\n\n  function processNode(\n    node: ChildNode,\n    _parentGroup: Omit<ResolvedElement, 'commonSanity'> | undefined,\n  ): void {\n    const resolvedElement = resolveNode(node)\n\n    let parentGroup: Omit<ResolvedElement, 'commonSanity'> | undefined = _parentGroup\n\n    if (isElementNode(node) && node.dataset?.['sanityEditGroup'] !== undefined) {\n      parentGroup = {\n        type: 'group',\n        elements: {\n          element: node,\n          measureElement: node,\n        },\n        targets: [],\n      }\n      mainResults.push(parentGroup)\n    }\n\n    if (resolvedElement) {\n      const target: ResolvedElementTarget = {\n        elements: resolvedElement.elements,\n        sanity: resolvedElement.sanity,\n        reason: resolvedElement.reason,\n      }\n      if (parentGroup && !resolvedElement.preventGrouping) {\n        parentGroup.targets.push(target)\n      } else {\n        mainResults.push({\n          elements: resolvedElement.elements,\n          type: 'element',\n          targets: [target],\n        })\n      }\n    }\n\n    const shouldTraverseNode =\n      isElementNode(node) &&\n      !isImgElement(node) &&\n      !(node.tagName === 'SCRIPT' || node.tagName === 'SANITY-VISUAL-EDITING')\n\n    if (shouldTraverseNode) {\n      for (const childNode of node.childNodes) {\n        processNode(childNode, parentGroup)\n      }\n    }\n  }\n\n  if (el) {\n    for (const node of el.childNodes) {\n      processNode(node, undefined)\n    }\n  }\n\n  return mainResults\n    .map((node) => {\n      if (node.targets.length === 0 && node.type === 'group') {\n        // Always return empty groups so the controller can unregister them\n        return {\n          ...node,\n          commonSanity: undefined,\n        }\n      }\n\n      const commonSanity =\n        node.targets.length === 1\n          ? node.targets[0].sanity\n          : findCommonSanityData(\n              node.targets.map(({sanity}) => sanity).filter((n) => n !== undefined),\n            ) || node.targets[0].sanity\n\n      if (!commonSanity) return null\n\n      return {\n        ...node,\n        commonSanity,\n      }\n    })\n    .filter((node) => node !== null)\n}\n\nexport function isSanityArrayPath(path: string): boolean {\n  const lastDotIndex = path.lastIndexOf('.')\n  const lastPathItem = path.substring(lastDotIndex, path.length)\n\n  return lastPathItem.includes('[')\n}\n\nexport function getSanityNodeArrayPath(path: string): string | null {\n  if (!isSanityArrayPath(path)) return null\n\n  const split = path.split('.')\n\n  split[split.length - 1] = split[split.length - 1].replace(/\\[.*?\\]/g, '[]')\n\n  return split.join('.')\n}\n\nexport function sanityNodesExistInSameArray(\n  sanityNode1: SanityNode,\n  sanityNode2: SanityNode,\n): boolean {\n  if (!isSanityArrayPath(sanityNode1.path) || !isSanityArrayPath(sanityNode2.path)) return false\n\n  return getSanityNodeArrayPath(sanityNode1.path) === getSanityNodeArrayPath(sanityNode2.path)\n}\n\nexport function resolveDragAndDropGroup(\n  element: ElementNode,\n  sanity: SanityNode | SanityStegaNode,\n  elementSet: Set<ElementNode>,\n  elementsMap: WeakMap<ElementNode, OverlayElement>,\n): null | OverlayElement[] {\n  if (!element.getAttribute('data-sanity')) return null\n\n  if (element.getAttribute('data-sanity-drag-disable')) return null\n\n  if (!sanity || !isSanityNode(sanity) || !isSanityArrayPath(sanity.path)) return null\n\n  const targetDragGroup = element.getAttribute('data-sanity-drag-group')\n\n  const group = [...elementSet].reduce<OverlayElement[]>((acc, el) => {\n    const elData = elementsMap.get(el)\n    const elDragDisabled = el.getAttribute('data-sanity-drag-disable')\n    const elDragGroup = el.getAttribute('data-sanity-drag-group')\n    const elHasSanityAttribution = el.getAttribute('data-sanity') !== null\n\n    const sharedDragGroup = targetDragGroup !== null ? targetDragGroup === elDragGroup : true\n\n    if (\n      elData?.sanity &&\n      !elDragDisabled &&\n      isSanityNode(elData.sanity) &&\n      sanityNodesExistInSameArray(sanity, elData.sanity) &&\n      sharedDragGroup &&\n      elHasSanityAttribution\n    ) {\n      acc.push(elData)\n    }\n\n    return acc\n  }, [])\n\n  if (group.length <= 1) return null\n\n  return group\n}\n","import {v4 as uuid} from 'uuid'\nimport type {\n  ElementNode,\n  EventHandlers,\n  OverlayController,\n  OverlayElement,\n  OverlayOptions,\n  ResolvedElement,\n} from './types'\nimport {handleOverlayDrag} from './util/dragAndDrop'\nimport {findOverlayElement, isElementNode} from './util/elements'\nimport {\n  findSanityNodes,\n  isSanityArrayPath,\n  isSanityNode,\n  resolveDragAndDropGroup,\n} from './util/findSanityNodes'\nimport {getRect} from './util/geometry'\n\n/**\n * Creates a controller which dispatches overlay related events\n *\n * @param handler - Dispatched event handler\n * @param overlayElement - Parent element containing rendered overlay elements\n * @public\n */\nexport function createOverlayController({\n  handler,\n  overlayElement,\n  inFrame,\n  inPopUp,\n  optimisticActorReady,\n}: OverlayOptions): OverlayController {\n  let activated = false\n  // Map for getting element by ID\n  const elementIdMap = new Map<string, ElementNode>()\n  // WeakMap for getting data by element\n  const elementsMap = new WeakMap<ElementNode, OverlayElement>()\n  // Set for iterating over elements\n  const elementSet = new Set<ElementNode>()\n  // Weakmap keyed by measureElement to find associated element\n  const measureElements = new WeakMap<ElementNode, ElementNode>()\n  // Weakmap for storing user set cursor styles per element\n  const cursorMap = new WeakMap<ElementNode, string | undefined>()\n\n  let ro: ResizeObserver\n  let io: IntersectionObserver | undefined\n  let mo: MutationObserver\n\n  let activeDragSequence = false\n\n  // The `hoverStack` is used as a container for tracking which elements are hovered at any time.\n  // The browser supports hovering multiple nested elements simultanously, but we only want to\n  // highlight the \"outer most\" element.\n  //\n  // This is how it works:\n  // - Whenever the mouse enters an element, we add it to the stack.\n  // - Whenever the mouse leaves an element, we remove it from the stack.\n  //\n  // When we want to know which element is currently hovered, we take the element at the top of the\n  // stack. Since JavaScript does not have a Stack type, we use an array and take the last element.\n  let hoverStack: Array<ElementNode> = []\n  const getHoveredElement = () => hoverStack[hoverStack.length - 1] as ElementNode | undefined\n\n  function addEventHandlers(el: ElementNode, handlers: EventHandlers) {\n    el.addEventListener('click', handlers.click as EventListener, {\n      capture: true,\n    })\n    el.addEventListener('contextmenu', handlers.contextmenu as EventListener, {\n      capture: true,\n    })\n    // We listen for the initial mousemove event, in case the overlay is enabled whilst the cursor is already over an element\n    // mouseenter and mouseleave listeners are attached within this handler\n    el.addEventListener('mousemove', handlers.mousemove as EventListener, {\n      once: true,\n      capture: true,\n    })\n    // Listen for mousedown in case we need to prevent default behavior\n    el.addEventListener('mousedown', handlers.mousedown as EventListener, {\n      capture: true,\n    })\n  }\n\n  function removeEventHandlers(el: ElementNode, handlers: EventHandlers) {\n    el.removeEventListener('click', handlers.click as EventListener, {\n      capture: true,\n    })\n    el.removeEventListener('contextmenu', handlers.contextmenu as EventListener, {\n      capture: true,\n    })\n    el.removeEventListener('mousemove', handlers.mousemove as EventListener, {\n      capture: true,\n    })\n    el.removeEventListener('mousedown', handlers.mousedown as EventListener, {\n      capture: true,\n    })\n    el.removeEventListener('mouseenter', handlers.mouseenter as EventListener)\n    el.removeEventListener('mouseleave', handlers.mouseleave as EventListener)\n  }\n\n  /**\n   * Executed when element enters the viewport\n   * Enables an element’s event handlers\n   */\n  function activateElement({id, elements, handlers}: OverlayElement) {\n    const {element, measureElement} = elements\n    addEventHandlers(element, handlers)\n    ro.observe(measureElement)\n    handler({\n      type: 'element/activate',\n      id,\n    })\n  }\n\n  /**\n   * Executed when element leaves the viewport\n   * Disables an element’s event handlers\n   */\n  function deactivateElement({id, elements, handlers}: OverlayElement) {\n    const {element, measureElement} = elements\n    removeEventHandlers(element, handlers)\n    ro.unobserve(measureElement)\n    // Scrolling from a hovered element will not trigger mouseleave event, so filter the stack\n    hoverStack = hoverStack.filter((el) => el !== element)\n    handler({\n      type: 'element/deactivate',\n      id,\n    })\n  }\n\n  function setOverlayCursor(element: ElementNode) {\n    // Don't set the cursor if mutations are unavailable\n    if ((!inFrame && !inPopUp) || !optimisticActorReady) return\n\n    // Loops through the entire hoverStack, trying to set the cursor if the\n    // stack element matches the element passed to the function, otherwise\n    // restoring the cursor\n    for (const hoverstackElement of hoverStack) {\n      if (element === hoverstackElement) {\n        const targetSanityData = elementsMap.get(element)?.sanity\n        if (!targetSanityData || !isSanityNode(targetSanityData)) return\n\n        const dragGroup = resolveDragAndDropGroup(\n          element,\n          targetSanityData,\n          elementSet,\n          elementsMap,\n        )\n\n        if (dragGroup) {\n          // Store any existing cursor so it can be restored later\n          const existingCursor = element.style.cursor\n          if (existingCursor) {\n            cursorMap.set(element, existingCursor)\n          }\n\n          handler({\n            type: 'overlay/setCursor',\n            element,\n            cursor: 'move',\n          })\n\n          continue\n        }\n      }\n\n      restoreOverlayCursor(hoverstackElement)\n    }\n  }\n\n  function restoreOverlayCursor(element: ElementNode) {\n    // Restore any previously stored cursor (if it exists)\n    const previousCursor = cursorMap.get(element)\n\n    handler({\n      type: 'overlay/setCursor',\n      element,\n      cursor: previousCursor,\n    })\n  }\n\n  /**\n   * Stores an element’s DOM node and decoded sanity data in state and sets up event handlers\n   */\n  function registerElement({type, elements, commonSanity, targets}: ResolvedElement) {\n    const {element, measureElement} = elements\n\n    const eventHandlers: EventHandlers = {\n      click(event) {\n        const target = event.target as ElementNode | null\n\n        if (element === getHoveredElement() && element.contains(target)) {\n          // Click events are only supported supported in iframes, not well supported in popups\n          // @TODO presentation tool should report wether it's visible or not, so we can adapt properly and allow multi-window preview workflows\n          if (inFrame) {\n            event.preventDefault()\n            event.stopPropagation()\n          }\n\n          const sanity = elementsMap.get(element)?.sanity\n          if (sanity && !activeDragSequence) {\n            handler({\n              type: 'element/click',\n              id,\n              sanity,\n            })\n          }\n        }\n      },\n      contextmenu(event) {\n        if (!('path' in commonSanity!) || (!inFrame && !inPopUp) || !optimisticActorReady) return\n\n        // This is a temporary check as the context menu only supports array\n        // items (for now). We split the path into segments, if a `_key` exists\n        // in last path segment, we assume it's an array item, and so return\n        // early if it is some other type.\n        if (!commonSanity.path.split('.').pop()?.includes('[_key==')) return\n\n        const target = event.target as ElementNode | null\n        if (element === getHoveredElement() && element.contains(target)) {\n          // Context menus are supported on both iframes and popups\n          if (inFrame || inPopUp) {\n            event.preventDefault()\n            event.stopPropagation()\n          }\n          handler({\n            type: 'element/contextmenu',\n            id,\n            position: {\n              x: event.clientX,\n              y: event.clientY,\n            },\n            sanity: commonSanity,\n          })\n        }\n      },\n      mousedown(event) {\n        // prevent iframe from taking focus\n        event.preventDefault()\n\n        if (event.currentTarget !== hoverStack.at(-1)) return\n\n        if (element.getAttribute('data-sanity-drag-disable')) return\n\n        // disable dnd in non-studio contexts\n        if ((!inFrame && !inPopUp) || !optimisticActorReady) return\n\n        const targetSanityData = elementsMap.get(element)?.sanity\n\n        if (\n          !targetSanityData ||\n          !isSanityNode(targetSanityData) ||\n          !isSanityArrayPath(targetSanityData.path)\n        )\n          return\n\n        const dragGroup = resolveDragAndDropGroup(element, commonSanity!, elementSet, elementsMap)\n\n        if (!dragGroup) return\n\n        handleOverlayDrag({\n          element,\n          handler,\n          mouseEvent: event as MouseEvent,\n          overlayGroup: dragGroup,\n          target: targetSanityData,\n          onSequenceStart: () => {\n            activeDragSequence = true\n          },\n          onSequenceEnd: () => {\n            // delay drag sequence end to prevent click events from firing just after drag sequences\n            setTimeout(() => {\n              activeDragSequence = false\n            }, 250)\n          },\n        })\n      },\n      mousemove(event) {\n        eventHandlers.mouseenter(event)\n        const el = event.currentTarget as ElementNode | null\n        if (el) {\n          el.addEventListener('mouseenter', eventHandlers.mouseenter as EventListener)\n          el.addEventListener('mouseleave', eventHandlers.mouseleave as EventListener)\n        }\n      },\n      mouseenter() {\n        // If the Vercel Visual Editing provided by Vercel Toolbar is active, do not overlap overlays\n        if (\n          (document.querySelector('vercel-live-feedback') &&\n            element.closest('[data-vercel-edit-info]')) ||\n          element.closest('[data-vercel-edit-target]')\n        ) {\n          return\n        }\n        hoverStack.push(element)\n\n        handler({\n          type: 'element/mouseenter',\n          id,\n          rect: getRect(element),\n        })\n\n        setOverlayCursor(element)\n      },\n      mouseleave(e) {\n        function leave() {\n          hoverStack.pop()\n          const hoveredElement = getHoveredElement()\n\n          handler({\n            type: 'element/mouseleave',\n            id,\n          })\n\n          if (hoveredElement) {\n            setOverlayCursor(hoveredElement)\n            const overlayElement = elementsMap.get(hoveredElement)\n            if (overlayElement) {\n              handler({\n                type: 'element/mouseenter',\n                id: overlayElement.id,\n                rect: getRect(hoveredElement),\n              })\n            }\n          }\n\n          restoreOverlayCursor(element)\n        }\n\n        /**\n         * If moving to an element within the overlay which handles pointer events, attach a new\n         * event handler to that element and defer the original leave event\n         */\n        function addDeferredLeave(el: ElementNode) {\n          const deferredLeave = (e: MouseEvent) => {\n            const {relatedTarget} = e\n            const deferredContainer = findOverlayElement(relatedTarget)\n            if (!deferredContainer) {\n              el.removeEventListener('mouseleave', deferredLeave as EventListener)\n              leave()\n            } else if (relatedTarget && isElementNode(relatedTarget)) {\n              el.removeEventListener('mouseleave', deferredLeave as EventListener)\n              addDeferredLeave(relatedTarget)\n            }\n          }\n          el.addEventListener('mouseleave', deferredLeave as EventListener)\n        }\n\n        const {relatedTarget} = e as MouseEvent\n        const container = findOverlayElement(relatedTarget)\n        const isInteractiveOverlayElement = overlayElement.contains(container)\n\n        if (isElementNode(container) && isInteractiveOverlayElement) {\n          return addDeferredLeave(container)\n        }\n\n        leave()\n      },\n    }\n\n    const id = uuid()\n    const sanityNode = {\n      type,\n      id,\n      elements,\n      sanity: commonSanity,\n      handlers: eventHandlers,\n    }\n    elementSet.add(element)\n    measureElements.set(measureElement, element)\n    elementIdMap.set(id, element)\n    elementsMap.set(element, sanityNode)\n\n    io?.observe(element)\n\n    handler({\n      type: 'element/register',\n      elementType: type,\n      id,\n      element,\n      rect: getRect(element),\n      sanity: commonSanity!,\n      dragDisabled: !!element.getAttribute('data-sanity-drag-disable'),\n      targets: targets.map((target) => ({\n        sanity: target.sanity,\n        element: target.elements.element,\n      })),\n    })\n\n    if (activated) {\n      activateElement(sanityNode)\n    }\n  }\n\n  function updateElement(resolvedElement: ResolvedElement) {\n    const {element} = resolvedElement.elements\n    const overlayElement = elementsMap.get(element)\n    if (overlayElement) {\n      elementsMap.set(element, {...overlayElement, sanity: resolvedElement.commonSanity})\n      handler({\n        type: 'element/update',\n        elementType: overlayElement.type,\n        id: overlayElement.id,\n        rect: getRect(element),\n        sanity: resolvedElement.commonSanity!,\n        targets: resolvedElement.targets.map((target) => ({\n          sanity: target.sanity,\n          element: target.elements.element,\n        })),\n      })\n    }\n  }\n\n  function parseElements(node: ElementNode | {childNodes: ElementNode[]}) {\n    const sanityNodes = findSanityNodes(node)\n\n    for (const sanityNode of sanityNodes) {\n      if (sanityNode.type === 'group') {\n        for (const target of sanityNode.targets) {\n          // Any child target of a group should be unregistered if registered as an element\n          const overlayElement = elementsMap.get(target.elements.element)\n          if (overlayElement && overlayElement.type === 'element') {\n            unregisterElement(target.elements.element)\n          }\n        }\n        if (sanityNode.targets.length === 0) {\n          // Group was updated without children, unregister the element\n          unregisterElement(sanityNode.elements.element)\n        }\n      }\n\n      if (!sanityNode.commonSanity) continue\n\n      const {element} = sanityNode.elements\n      if (elementsMap.has(element)) {\n        updateElement(sanityNode)\n      } else {\n        registerElement(sanityNode)\n      }\n    }\n  }\n\n  function unregisterElement(element: ElementNode) {\n    const overlayElement = elementsMap.get(element)\n    if (overlayElement) {\n      const {id, handlers} = overlayElement\n      removeEventHandlers(element, handlers)\n      ro.unobserve(element)\n      elementsMap.delete(element)\n      elementSet.delete(element)\n      elementIdMap.delete(id)\n      handler({\n        type: 'element/unregister',\n        id,\n      })\n    }\n  }\n\n  function handleMutation(mutations: MutationRecord[]) {\n    let mutationWasInScope = false\n    // For each DOM mutation, we find the relevant element node and register or\n    // update it. This function doesn't handle checking if the node actually\n    // contains any relevant Sanity data, it just detects new or changed DOM\n    // elements and hands them off to `parseElements` to and determine if we\n    // have Sanity nodes\n    for (const mutation of mutations) {\n      const {target, type} = mutation\n      // We need to target an element, so if the mutated node was just a text\n      // change, we look at that node's parent instead\n      const node: Node | null = type === 'characterData' ? target.parentElement : target\n      // We ignore any nodes related to the overlay container element\n      if (node === overlayElement || overlayElement.contains(node)) {\n        continue\n      }\n\n      mutationWasInScope = true\n      if (isElementNode(node)) {\n        const possibleGroupParent = node.parentElement?.closest('[data-sanity-edit-group]') || null\n        const updateNodeTarget = isElementNode(possibleGroupParent) ? possibleGroupParent : node\n        parseElements({childNodes: [updateNodeTarget]})\n      }\n    }\n\n    // If the mutation is \"in scope\" (i.e. happened outside of the overlay\n    // container) we need to check if it removed any of the elements we are\n    // currently tracking\n    if (mutationWasInScope) {\n      for (const element of elementSet) {\n        if (!element.isConnected) {\n          unregisterElement(element)\n        }\n        // If the element was a group and is no longer a group, unregister it\n        const overlayElement = elementsMap.get(element)\n        if (overlayElement?.type === 'group' && !element.hasAttribute('data-sanity-edit-group')) {\n          unregisterElement(element)\n        }\n      }\n    }\n  }\n\n  function updateRect(el: ElementNode) {\n    const overlayElement = elementsMap.get(el)\n    if (overlayElement) {\n      handler({\n        type: 'element/updateRect',\n        id: overlayElement.id,\n        rect: getRect(el),\n      })\n    }\n  }\n\n  function handleResize(entries: ResizeObserverEntry[]) {\n    for (const entry of entries) {\n      const target = entry.target\n\n      if (isElementNode(target)) {\n        const element = measureElements.get(target)\n        if (!element) return\n        updateRect(element)\n      }\n    }\n  }\n\n  function handleIntersection(entries: IntersectionObserverEntry[]) {\n    if (!activated) return\n    for (const entry of entries) {\n      const {target} = entry\n      const match = isElementNode(target) && elementsMap.get(target)\n      if (!match) continue\n      if (entry.isIntersecting) {\n        activateElement(match)\n      } else {\n        deactivateElement(match)\n      }\n    }\n  }\n\n  function handleBlur(event: MouseEvent) {\n    const element = findOverlayElement(event.target)\n\n    if (element) {\n      if (element.dataset['sanityOverlayElement'] === 'capture') {\n        event.preventDefault()\n        event.stopPropagation()\n      }\n      return\n    }\n\n    hoverStack = []\n    handler({\n      type: 'overlay/blur',\n    })\n  }\n\n  function handleExclusivePluginClosed() {\n    hoverStack = []\n    handler({\n      type: 'overlay/reset-mouse-state',\n    })\n  }\n\n  function handleWindowResize() {\n    for (const element of elementSet) {\n      updateRect(element)\n    }\n  }\n\n  function handleKeydown(event: KeyboardEvent) {\n    if (event.key === 'Escape') {\n      hoverStack = []\n      handler({\n        type: 'overlay/blur',\n      })\n    }\n  }\n\n  function handleWindowScroll(event: Event) {\n    const {target} = event\n\n    if (target === window.document || !isElementNode(target)) {\n      return\n    }\n\n    for (const element of elementSet) {\n      if (target.contains(element)) {\n        updateRect(element)\n      }\n    }\n  }\n\n  function activate() {\n    if (activated) return\n    io = new IntersectionObserver(handleIntersection, {\n      threshold: 0.3,\n    })\n    elementSet.forEach((element) => io!.observe(element))\n    handler({\n      type: 'overlay/activate',\n    })\n    activated = true\n  }\n\n  function deactivate() {\n    if (!activated) return\n    io?.disconnect()\n    elementSet.forEach((element) => {\n      const overlayElement = elementsMap.get(element)\n      if (overlayElement) {\n        deactivateElement(overlayElement)\n      }\n    })\n    handler({\n      type: 'overlay/deactivate',\n    })\n    activated = false\n  }\n\n  function handleHeaderClick(event: CustomEvent<{id: string}>) {\n    const {id} = event.detail\n    const element = elementIdMap.get(id)\n    if (!element) return\n    const sanity = elementsMap.get(element)?.sanity\n    if (!sanity) return\n    handler({\n      type: 'element/click',\n      id,\n      sanity,\n    })\n  }\n\n  function destroy() {\n    window.removeEventListener('click', handleBlur)\n    window.removeEventListener('contextmenu', handleBlur)\n    window.removeEventListener(\n      'sanity-overlay/exclusive-plugin-closed',\n      handleExclusivePluginClosed,\n    )\n    window.removeEventListener('sanity-overlay/label-click', handleHeaderClick as EventListener)\n    window.removeEventListener('keydown', handleKeydown)\n    window.removeEventListener('resize', handleWindowResize)\n    window.removeEventListener('scroll', handleWindowScroll)\n    mo.disconnect()\n    ro.disconnect()\n\n    elementSet.forEach((element) => {\n      unregisterElement(element)\n    })\n\n    elementIdMap.clear()\n    elementSet.clear()\n\n    hoverStack = []\n    deactivate()\n  }\n\n  function create() {\n    window.addEventListener('click', handleBlur)\n    window.addEventListener('contextmenu', handleBlur)\n    window.addEventListener('sanity-overlay/exclusive-plugin-closed', handleExclusivePluginClosed)\n    window.addEventListener('sanity-overlay/label-click', handleHeaderClick as EventListener)\n    window.addEventListener('keydown', handleKeydown)\n    window.addEventListener('resize', handleWindowResize)\n    window.addEventListener('scroll', handleWindowScroll, {\n      capture: true,\n      passive: true,\n    })\n    ro = new ResizeObserver(handleResize)\n    mo = new MutationObserver(handleMutation)\n    mo.observe(document.body, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n    })\n\n    parseElements(document.body)\n    activate()\n  }\n\n  window.document.fonts.ready.then(() => {\n    for (const element of elementSet) {\n      updateRect(element)\n    }\n  })\n\n  create()\n\n  return {\n    activate,\n    deactivate,\n    destroy,\n  }\n}\n","import {createContext} from 'react'\nimport type {VisualEditingNode} from '../../types'\nimport type {SharedStateStore} from './sharedStateStore'\n\nexport interface SharedStateContextValue {\n  comlink?: VisualEditingNode\n  store: SharedStateStore\n}\n\nexport const SharedStateContext = createContext<SharedStateContextValue | null>(null)\n"],"names":["useOptimistic","passthrough","reducer","$","_c","pristine","setPristine","useState","optimistic","setOptimistic","lastEvent","setLastEvent","lastPassthrough","setLastPassthrough","actor","useOptimisticActor","reduceStateFromActionRef","useRef","t0","t1","current","action","prevState","Array","isArray","reduce","acc","reducer_0","document","id","getPublishedId","originalId","type","useInsertionEffect","t2","updateLastPassthroughRef","t3","t4","t5","t6","isEmptyActor","pristineTimeout","rebasedSub","on","_event","event","prevState_0","clearTimeout","pristineSub","setTimeout","startTransition","unsubscribe","useEffect","t7","t8","Error","byteToHex","i","push","toString","slice","unsafeStringify","arr","offset","toLowerCase","getRandomValues","rnds8","Uint8Array","rng","crypto","bind","randomUUID","v4","options","buf","native","rnds","random","length","getRect","element","domRect","getBoundingClientRect","x","scrollX","y","scrollY","w","width","h","height","offsetRect","rect","px","axis","rayIntersect","l1","l2","x1","y1","x2","y2","x3","y3","x4","y4","denominator","ua","ub","rectEqual","r1","r2","rayRectIntersections","line","rectLines","intersections","intersection","isDuplicate","j","sort","a","b","pointDist","p1","p2","Math","sqrt","pointInBounds","point","bounds","withinX","withinY","findClosestIntersection","ray","targets","flow","rayOrigin","some","t","min","closestIntersection","closestRect","target","firstIntersection","scaleRect","scale","origin","originX","originY","newX","newY","newWidth","newHeight","getRectGroupXExtent","rects","minGroupX","max","map","r","maxGroupX","body","offsetWidth","getRectGroupYExtent","minGroupY","maxGroupY","scrollHeight","calcTargetFlow","filter","calcInsertPosition","rayLeft","rayRight","left","right","rayTop","rayBottom","top","bottom","findRectSanityData","overlayGroup","find","e","elements","sanity","resolveInsertPosition","insertPosition","Object","values","every","v","calcMousePos","bodyBounds","clientX","clientY","window","calcMousePosInverseTransform","mousePos","transform","getComputedStyle","inverseMatrix","DOMMatrix","inverse","transformedPoint","DOMPoint","matrixTransform","buildPreviewSkeleton","scaleFactor","children","querySelectorAll","childRects","child","tagName","offsetX","offsetY","maxWidth","minDragDelta","applyMinimapWrapperTransform","minYScaled","handler","rectUpdateFrequency","Promise","resolve","addEventListener","once","display","style","overflow","documentElement","transformOrigin","transition","calcMinimapTransformValues","groupHeightOverride","groupHeight","padding","innerHeight","scaledRects","innerWidth","calcGroupBoundsPreview","groupBoundsX","groupBoundsY","offsetDist","canOffsetX","canOffsetY","canOffset","resetMinimapWrapperTransform","endYOrigin","prescaleHeight","previousRootStyleValues","maxScroll","prevScrollY","scrollTo","behavior","minimapScaleApplied","mousePosInverseTransform","handleOverlayDrag","opts","mouseEvent","onSequenceStart","onSequenceEnd","button","focus","getAttribute","dragGroup","disableMinimap","preventInsertDefault","documentHeightOverride","initialMousePos","scaleTarget","sequenceStarted","minimapPromptShown","mousedown","rectsInterval","setInterval","applyMinimap","skeleton","then","groupRect","handleScroll","abs","deltaY","shiftKey","dispatchEvent","CustomEvent","handleMouseMove","preventDefault","newInsertPosition","JSON","stringify","handleMouseUp","clearInterval","removeFrameListeners","removeKeyListeners","removeMouseListeners","handleKeyup","key","handleBlur","removeEventListener","isElementNode","HTMLElement","SVGElement","findNonInlineElement","parent","parentElement","findOverlayElement","el","dataset","testVercelStegaRegex","input","VERCEL_STEGA_REGEX","lastIndex","test","decodeStega","str","isAltText","decoded","vercelStegaDecode","href","replace","err","console","error","testAndDecodeStega","node","nodeType","Node","ELEMENT_NODE","isImgElement","isTimeElement","isSvgRootElement","toUpperCase","isSanityNode","findCommonPath","first","second","firstParts","split","secondParts","maxLength","reverse","parts","part","join","findCommonSanityData","nodes","n","_i","sanityNodes","common","consistentValueKeys","undefined","path","findSanityNodes","mainResults","createResolvedElement","data","reason","preventGrouping","decodeSanityNodeData","measureElement","resolveNode","textContent","nodesInTarget","commonData","commonSanity","TEXT_NODE","Boolean","alt","dateTime","ariaLabel","processNode","_parentGroup","resolvedElement","parentGroup","childNode","childNodes","isSanityArrayPath","lastDotIndex","lastIndexOf","substring","includes","getSanityNodeArrayPath","sanityNodesExistInSameArray","sanityNode1","sanityNode2","resolveDragAndDropGroup","elementSet","elementsMap","targetDragGroup","group","elData","get","elDragDisabled","elDragGroup","elHasSanityAttribution","sharedDragGroup","createOverlayController","overlayElement","inFrame","inPopUp","optimisticActorReady","activated","elementIdMap","Map","WeakMap","Set","measureElements","cursorMap","ro","io","mo","activeDragSequence","hoverStack","getHoveredElement","addEventHandlers","handlers","click","capture","contextmenu","mousemove","removeEventHandlers","mouseenter","mouseleave","activateElement","observe","deactivateElement","unobserve","setOverlayCursor","hoverstackElement","targetSanityData","existingCursor","cursor","set","restoreOverlayCursor","previousCursor","registerElement","eventHandlers","contains","stopPropagation","pop","position","currentTarget","at","querySelector","closest","leave","hoveredElement","addDeferredLeave","deferredLeave","relatedTarget","container","isInteractiveOverlayElement","uuid","sanityNode","add","elementType","dragDisabled","updateElement","parseElements","unregisterElement","has","delete","handleMutation","mutations","mutationWasInScope","mutation","possibleGroupParent","updateNodeTarget","isConnected","hasAttribute","updateRect","handleResize","entries","entry","handleIntersection","match","isIntersecting","handleExclusivePluginClosed","handleWindowResize","handleKeydown","handleWindowScroll","activate","IntersectionObserver","threshold","forEach","deactivate","disconnect","handleHeaderClick","detail","destroy","clear","create","passive","ResizeObserver","MutationObserver","attributes","characterData","childList","subtree","fonts","ready","SharedStateContext","createContext"],"mappings":"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","x_google_ignoreList":[1,2,3,4]}